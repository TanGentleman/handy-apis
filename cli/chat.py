"""Chat environment setup for local and cloud agents.

This module handles:
- Local mode: symlink docs into project + generate DOCS.md
- Cloud mode: Upload to Modal Volume + create OpenCode Sandbox
"""

import os
import sys
from pathlib import Path
from typing import Optional

from cli.store import (
    DOCPULL_HOME,
    collection_exists,
    get_collection_path,
    get_manifest,
)


def setup_local_chat(
    collection: str,
    project_dir: Optional[Path] = None,
    docs_dir_name: str = "docs",
) -> dict:
    """Set up local chat environment with symlinked docs.

    Creates:
    - ./docs/<collection> -> ~/.docpull/<collection> (symlink)
    - ./DOCS.md with instructions for the agent

    Args:
        collection: The collection ID to link
        project_dir: Project directory (defaults to cwd)
        docs_dir_name: Name of docs directory (default: "docs")

    Returns:
        dict with status and paths

    Raises:
        ValueError: If collection doesn't exist
    """
    if not collection_exists(collection):
        raise ValueError(
            f"Collection '{collection}' not found. "
            f"Run 'docpull load {collection}' first."
        )

    project_dir = project_dir or Path.cwd()
    docs_dir = project_dir / docs_dir_name
    target_link = docs_dir / collection
    source_path = get_collection_path(collection)

    # Create docs directory if needed
    docs_dir.mkdir(parents=True, exist_ok=True)

    # Remove existing symlink/dir if present
    if target_link.is_symlink():
        target_link.unlink()
    elif target_link.is_dir():
        import shutil
        shutil.rmtree(target_link)

    # Create symlink
    target_link.symlink_to(source_path, target_is_directory=True)

    # Generate DOCS.md
    docs_md_path = project_dir / "DOCS.md"
    manifest = get_manifest()
    meta = manifest.get("collections", {}).get(collection, {})

    docs_md_content = f"""# Documentation Context

This project has access to the following documentation:

## {collection}

- **Location**: `{docs_dir_name}/{collection}/`
- **Pages**: {meta.get('pages', 'unknown')}
- **Loaded**: {meta.get('loaded_at', 'unknown')}

## Usage

When working on this project, reference the documentation in `{docs_dir_name}/{collection}/` for:
- API references
- Code examples
- Best practices

The documentation is in markdown format and can be read directly.

---
*Generated by docpull*
"""

    # Check if DOCS.md exists and has different content
    write_docs_md = True
    if docs_md_path.exists():
        existing = docs_md_path.read_text()
        if collection in existing:
            # Already has this collection, append if different
            write_docs_md = False

    if write_docs_md:
        with open(docs_md_path, "w") as f:
            f.write(docs_md_content)

    return {
        "success": True,
        "symlink": str(target_link),
        "source": str(source_path),
        "docs_md": str(docs_md_path) if write_docs_md else None,
        "collection": collection,
    }


def setup_cloud_chat(
    collection: str,
    volume_name: str = "docpull-docs",
) -> dict:
    """Set up cloud chat environment with Modal Sandbox.

    This:
    1. Uploads collection to a Modal Volume
    2. Creates a Modal Sandbox with OpenCode
    3. Returns connection info (URL, password, etc.)

    Args:
        collection: The collection ID to use
        volume_name: Modal Volume name (default: docpull-docs)

    Returns:
        dict with sandbox info (url, password, sandbox_id, etc.)

    Raises:
        ValueError: If collection doesn't exist
        ImportError: If modal is not installed
    """
    if not collection_exists(collection):
        raise ValueError(
            f"Collection '{collection}' not found. "
            f"Run 'docpull load {collection}' first."
        )

    try:
        import modal
    except ImportError:
        raise ImportError(
            "Modal is required for cloud chat. Install with: pip install modal"
        )

    import secrets

    collection_path = get_collection_path(collection)

    # Create or get volume
    volume = modal.Volume.from_name(volume_name, create_if_missing=True)

    # Upload docs to volume
    print(f"Uploading {collection} to Modal Volume...", file=sys.stderr)

    # batch_upload handles the remote write when the context manager exits
    with volume.batch_upload() as batch:
        for file_path in collection_path.rglob("*.md"):
            relative = file_path.relative_to(collection_path)
            remote_path = f"/docs/{collection}/{relative}"
            batch.put_file(file_path, remote_path)

    print(f"Uploaded to volume: {volume_name}", file=sys.stderr)

    # Reuse the sandbox module's image builder and constants
    from sandbox.opencode import get_opencode_image, APP_NAME, OPENCODE_PORT

    # Generate password for OpenCode
    password = secrets.token_urlsafe(12)
    password_secret = modal.Secret.from_dict({"OPENCODE_SERVER_PASSWORD": password})

    # Create sandbox with OpenCode
    print("Creating Modal Sandbox with OpenCode...", file=sys.stderr)

    image = get_opencode_image()
    app = modal.App.lookup(APP_NAME, create_if_missing=True)

    with modal.enable_output():
        sandbox = modal.Sandbox.create(
            "opencode",
            "serve",
            "--hostname=0.0.0.0",
            f"--port={OPENCODE_PORT}",
            image=image,
            app=app,
            secrets=[password_secret],
            volumes={"/docs": volume},
            workdir=f"/docs/{collection}",
            encrypted_ports=[OPENCODE_PORT],
            timeout=3600,  # 1 hour
        )

    # Get tunnel URL
    tunnel = sandbox.tunnels()[OPENCODE_PORT]
    web_url = tunnel.url

    return {
        "success": True,
        "sandbox_id": sandbox.object_id,
        "web_url": web_url,
        "password": password,
        "username": "opencode",
        "collection": collection,
        "docs_path": f"/docs/{collection}",
        "volume": volume_name,
        "commands": {
            "attach_tui": f"OPENCODE_SERVER_PASSWORD={password} opencode attach {web_url}",
            "shell": f"modal shell {sandbox.object_id}",
        },
    }


def stop_sandbox(sandbox_id: str) -> bool:
    """Stop a running Modal Sandbox.

    Args:
        sandbox_id: The sandbox ID to stop

    Returns:
        True if stopped successfully
    """
    try:
        import modal
    except ImportError:
        raise ImportError("Modal is required. Install with: pip install modal")

    sandbox = modal.Sandbox.from_id(sandbox_id)
    sandbox.terminate()
    return True


def list_sandboxes() -> list[dict]:
    """List running docpull sandboxes.

    Returns:
        List of sandbox info dicts
    """
    try:
        import modal
    except ImportError:
        return []

    # Note: Modal doesn't have a direct API to list sandboxes by tag,
    # so this is a placeholder for future implementation
    return []
